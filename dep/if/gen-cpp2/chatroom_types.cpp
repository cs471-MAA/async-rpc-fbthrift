/**
 * Autogenerated by Thrift for /home/adrien/Documents/epfl/MA/cs-471/project/dep/if/chatroom.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "if/gen-cpp2/chatroom_types.h"
#include "if/gen-cpp2/chatroom_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "if/gen-cpp2/chatroom_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::example::chatroom::Message>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::example::chatroom::Message>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace example { namespace chatroom {

Message::Message(const Message&) = default;
Message& Message::operator=(const Message&) = default;
Message::Message(Message&& other) noexcept  :
    __fbthrift_field_message(std::move(other.__fbthrift_field_message)),
    __fbthrift_field_sender(std::move(other.__fbthrift_field_sender)),
    __fbthrift_field_timestamp(std::move(other.__fbthrift_field_timestamp)),
    __isset(other.__isset) {
}

Message& Message::operator=(FOLLY_MAYBE_UNUSED Message&& other) noexcept {
    this->__fbthrift_field_message = std::move(other.__fbthrift_field_message);
    this->__fbthrift_field_sender = std::move(other.__fbthrift_field_sender);
    this->__fbthrift_field_timestamp = std::move(other.__fbthrift_field_timestamp);
    __isset = other.__isset;
    return *this;
}


Message::Message(apache::thrift::FragileConstructor, ::std::string message__arg, ::std::string sender__arg, ::std::int64_t timestamp__arg) :
    __fbthrift_field_message(std::move(message__arg)),
    __fbthrift_field_sender(std::move(sender__arg)),
    __fbthrift_field_timestamp(std::move(timestamp__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void Message::__clear() {
  // clear all fields
  this->__fbthrift_field_message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_sender = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_timestamp = ::std::int64_t();
  __isset = {};
}

bool Message::operator==(const Message& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return false;
  }
  if (!(lhs.sender_ref() == rhs.sender_ref())) {
    return false;
  }
  if (!(lhs.timestamp_ref() == rhs.timestamp_ref())) {
    return false;
  }
  return true;
}

bool Message::operator<(const Message& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return lhs.message_ref() < rhs.message_ref();
  }
  if (!(lhs.sender_ref() == rhs.sender_ref())) {
    return lhs.sender_ref() < rhs.sender_ref();
  }
  if (!(lhs.timestamp_ref() == rhs.timestamp_ref())) {
    return lhs.timestamp_ref() < rhs.timestamp_ref();
  }
  return false;
}


void swap(Message& a, Message& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.sender_ref().value(), b.sender_ref().value());
  swap(a.timestamp_ref().value(), b.timestamp_ref().value());
  swap(a.__isset, b.__isset);
}

template void Message::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Message::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Message::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Message::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Message::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Message::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Message::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Message::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // example::chatroom

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::example::chatroom::IndexToken>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::example::chatroom::IndexToken>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace example { namespace chatroom {


IndexToken::IndexToken(apache::thrift::FragileConstructor, ::std::int64_t index__arg) :
    __fbthrift_field_index(std::move(index__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void IndexToken::__clear() {
  // clear all fields
  this->__fbthrift_field_index = ::std::int64_t();
  __isset = {};
}

bool IndexToken::operator==(const IndexToken& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.index_ref() == rhs.index_ref())) {
    return false;
  }
  return true;
}

bool IndexToken::operator<(const IndexToken& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.index_ref() == rhs.index_ref())) {
    return lhs.index_ref() < rhs.index_ref();
  }
  return false;
}


void swap(IndexToken& a, IndexToken& b) {
  using ::std::swap;
  swap(a.index_ref().value(), b.index_ref().value());
  swap(a.__isset, b.__isset);
}

template void IndexToken::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t IndexToken::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t IndexToken::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t IndexToken::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void IndexToken::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t IndexToken::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t IndexToken::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t IndexToken::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // example::chatroom

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::example::chatroom::GetMessagesRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::example::chatroom::GetMessagesRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace example { namespace chatroom {


GetMessagesRequest::GetMessagesRequest(apache::thrift::FragileConstructor, ::example::chatroom::IndexToken token__arg) :
    __fbthrift_field_token(std::move(token__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void GetMessagesRequest::__clear() {
  // clear all fields
  this->__fbthrift_field_token.__clear();
  __isset = {};
}

bool GetMessagesRequest::operator==(const GetMessagesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.token_ref() == rhs.token_ref())) {
    return false;
  }
  return true;
}

bool GetMessagesRequest::operator<(const GetMessagesRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.token_ref() == rhs.token_ref())) {
    return lhs.token_ref() < rhs.token_ref();
  }
  return false;
}

const ::example::chatroom::IndexToken* GetMessagesRequest::get_token() const& {
  return token_ref().has_value() ? std::addressof(__fbthrift_field_token) : nullptr;
}

::example::chatroom::IndexToken* GetMessagesRequest::get_token() & {
  return token_ref().has_value() ? std::addressof(__fbthrift_field_token) : nullptr;
}


void swap(GetMessagesRequest& a, GetMessagesRequest& b) {
  using ::std::swap;
  swap(a.token_ref().value_unchecked(), b.token_ref().value_unchecked());
  swap(a.__isset, b.__isset);
}

template void GetMessagesRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetMessagesRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetMessagesRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetMessagesRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetMessagesRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetMessagesRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetMessagesRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetMessagesRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetMessagesRequest,
        ::apache::thrift::type_class::structure,
        ::example::chatroom::IndexToken>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetMessagesRequest,
        ::apache::thrift::type_class::structure,
        ::example::chatroom::IndexToken>,
    "inconsistent use of nimble option");

}} // example::chatroom

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::example::chatroom::GetMessagesResponse>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::example::chatroom::GetMessagesResponse>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace example { namespace chatroom {

GetMessagesResponse::GetMessagesResponse(const GetMessagesResponse&) = default;
GetMessagesResponse& GetMessagesResponse::operator=(const GetMessagesResponse&) = default;
GetMessagesResponse::GetMessagesResponse(GetMessagesResponse&& other) noexcept  :
    __fbthrift_field_messages(std::move(other.__fbthrift_field_messages)),
    __fbthrift_field_token(std::move(other.__fbthrift_field_token)),
    __isset(other.__isset) {
}

GetMessagesResponse& GetMessagesResponse::operator=(FOLLY_MAYBE_UNUSED GetMessagesResponse&& other) noexcept {
    this->__fbthrift_field_messages = std::move(other.__fbthrift_field_messages);
    this->__fbthrift_field_token = std::move(other.__fbthrift_field_token);
    __isset = other.__isset;
    return *this;
}


GetMessagesResponse::GetMessagesResponse(apache::thrift::FragileConstructor, ::std::vector<::example::chatroom::Message> messages__arg, ::example::chatroom::IndexToken token__arg) :
    __fbthrift_field_messages(std::move(messages__arg)),
    __fbthrift_field_token(std::move(token__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void GetMessagesResponse::__clear() {
  // clear all fields
  this->__fbthrift_field_messages.clear();
  this->__fbthrift_field_token.__clear();
  __isset = {};
}

bool GetMessagesResponse::operator==(const GetMessagesResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.messages_ref() == rhs.messages_ref())) {
    return false;
  }
  if (!(lhs.token_ref() == rhs.token_ref())) {
    return false;
  }
  return true;
}

bool GetMessagesResponse::operator<(const GetMessagesResponse& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.messages_ref() == rhs.messages_ref())) {
    return lhs.messages_ref() < rhs.messages_ref();
  }
  if (!(lhs.token_ref() == rhs.token_ref())) {
    return lhs.token_ref() < rhs.token_ref();
  }
  return false;
}

const ::std::vector<::example::chatroom::Message>& GetMessagesResponse::get_messages() const& {
  return __fbthrift_field_messages;
}

::std::vector<::example::chatroom::Message> GetMessagesResponse::get_messages() && {
  return std::move(__fbthrift_field_messages);
}

const ::example::chatroom::IndexToken& GetMessagesResponse::get_token() const& {
  return __fbthrift_field_token;
}

::example::chatroom::IndexToken GetMessagesResponse::get_token() && {
  return std::move(__fbthrift_field_token);
}


void swap(GetMessagesResponse& a, GetMessagesResponse& b) {
  using ::std::swap;
  swap(a.messages_ref().value(), b.messages_ref().value());
  swap(a.token_ref().value(), b.token_ref().value());
  swap(a.__isset, b.__isset);
}

template void GetMessagesResponse::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t GetMessagesResponse::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t GetMessagesResponse::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t GetMessagesResponse::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void GetMessagesResponse::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t GetMessagesResponse::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t GetMessagesResponse::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t GetMessagesResponse::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetMessagesResponse,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::example::chatroom::Message>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        GetMessagesResponse,
        ::apache::thrift::type_class::structure,
        ::example::chatroom::IndexToken>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetMessagesResponse,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::example::chatroom::Message>>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        GetMessagesResponse,
        ::apache::thrift::type_class::structure,
        ::example::chatroom::IndexToken>,
    "inconsistent use of nimble option");

}} // example::chatroom

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::example::chatroom::SendMessageRequest>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::example::chatroom::SendMessageRequest>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace example { namespace chatroom {

SendMessageRequest::SendMessageRequest(const SendMessageRequest&) = default;
SendMessageRequest& SendMessageRequest::operator=(const SendMessageRequest&) = default;
SendMessageRequest::SendMessageRequest(SendMessageRequest&& other) noexcept  :
    __fbthrift_field_message(std::move(other.__fbthrift_field_message)),
    __fbthrift_field_sender(std::move(other.__fbthrift_field_sender)),
    __isset(other.__isset) {
}

SendMessageRequest& SendMessageRequest::operator=(FOLLY_MAYBE_UNUSED SendMessageRequest&& other) noexcept {
    this->__fbthrift_field_message = std::move(other.__fbthrift_field_message);
    this->__fbthrift_field_sender = std::move(other.__fbthrift_field_sender);
    __isset = other.__isset;
    return *this;
}


SendMessageRequest::SendMessageRequest(apache::thrift::FragileConstructor, ::std::string message__arg, ::std::string sender__arg) :
    __fbthrift_field_message(std::move(message__arg)),
    __fbthrift_field_sender(std::move(sender__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void SendMessageRequest::__clear() {
  // clear all fields
  this->__fbthrift_field_message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_sender = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

bool SendMessageRequest::operator==(const SendMessageRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return false;
  }
  if (!(lhs.sender_ref() == rhs.sender_ref())) {
    return false;
  }
  return true;
}

bool SendMessageRequest::operator<(const SendMessageRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return lhs.message_ref() < rhs.message_ref();
  }
  if (!(lhs.sender_ref() == rhs.sender_ref())) {
    return lhs.sender_ref() < rhs.sender_ref();
  }
  return false;
}


void swap(SendMessageRequest& a, SendMessageRequest& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.sender_ref().value(), b.sender_ref().value());
  swap(a.__isset, b.__isset);
}

template void SendMessageRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t SendMessageRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t SendMessageRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t SendMessageRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void SendMessageRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t SendMessageRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t SendMessageRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t SendMessageRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // example::chatroom

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::example::chatroom::Exception>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::example::chatroom::Exception>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace example { namespace chatroom {

Exception::Exception(const Exception&) = default;
Exception& Exception::operator=(const Exception&) = default;
Exception::Exception() {
}


Exception::~Exception() {}

Exception::Exception(Exception&& other) noexcept  :
    message(std::move(other.message)),
    __isset(other.__isset) {
}

Exception& Exception::operator=(FOLLY_MAYBE_UNUSED Exception&& other) noexcept {
    this->message = std::move(other.message);
    __isset = other.__isset;
    return *this;
}


Exception::Exception(apache::thrift::FragileConstructor, ::std::string message__arg) :
    message(std::move(message__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void Exception::__clear() {
  // clear all fields
  this->message = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

bool Exception::operator==(const Exception& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return false;
  }
  return true;
}

bool Exception::operator<(const Exception& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.message_ref() == rhs.message_ref())) {
    return lhs.message_ref() < rhs.message_ref();
  }
  return false;
}


void swap(Exception& a, Exception& b) {
  using ::std::swap;
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.__isset, b.__isset);
}

template void Exception::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Exception::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Exception::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Exception::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Exception::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Exception::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Exception::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Exception::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // example::chatroom

namespace example { namespace chatroom { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}} // example::chatroom
