/**
 * Autogenerated by Thrift for /home/adrien/Documents/epfl/MA/cs-471/project/dep/if/chatroom.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "if/gen-cpp2/chatroom_metadata.h"

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);


const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::example::chatroom::Message>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("chatroom.Message", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& chatroom_Message = res.first->second;
  chatroom_Message.name_ref() = "chatroom.Message";
  chatroom_Message.is_union_ref() = false;
  static const EncodedThriftField
  chatroom_Message_fields[] = {
    {1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "sender", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}},
    {3, "timestamp", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_Message_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    chatroom_Message.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::example::chatroom::IndexToken>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("chatroom.IndexToken", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& chatroom_IndexToken = res.first->second;
  chatroom_IndexToken.name_ref() = "chatroom.IndexToken";
  chatroom_IndexToken.is_union_ref() = false;
  static const EncodedThriftField
  chatroom_IndexToken_fields[] = {
    {1, "index", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_I64_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_IndexToken_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    chatroom_IndexToken.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::example::chatroom::GetMessagesRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("chatroom.GetMessagesRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& chatroom_GetMessagesRequest = res.first->second;
  chatroom_GetMessagesRequest.name_ref() = "chatroom.GetMessagesRequest";
  chatroom_GetMessagesRequest.is_union_ref() = false;
  static const EncodedThriftField
  chatroom_GetMessagesRequest_fields[] = {
    {1, "token", true, std::make_unique<Struct< ::example::chatroom::IndexToken>>("chatroom.IndexToken"), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_GetMessagesRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    chatroom_GetMessagesRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::example::chatroom::GetMessagesResponse>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("chatroom.GetMessagesResponse", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& chatroom_GetMessagesResponse = res.first->second;
  chatroom_GetMessagesResponse.name_ref() = "chatroom.GetMessagesResponse";
  chatroom_GetMessagesResponse.is_union_ref() = false;
  static const EncodedThriftField
  chatroom_GetMessagesResponse_fields[] = {
    {1, "messages", false, std::make_unique<List>(std::make_unique<Struct< ::example::chatroom::Message>>("chatroom.Message")), std::vector<ThriftConstStruct>{}},
    {2, "token", false, std::make_unique<Struct< ::example::chatroom::IndexToken>>("chatroom.IndexToken"), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_GetMessagesResponse_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    chatroom_GetMessagesResponse.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::example::chatroom::SendMessageRequest>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("chatroom.SendMessageRequest", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& chatroom_SendMessageRequest = res.first->second;
  chatroom_SendMessageRequest.name_ref() = "chatroom.SendMessageRequest";
  chatroom_SendMessageRequest.is_union_ref() = false;
  static const EncodedThriftField
  chatroom_SendMessageRequest_fields[] = {
    {1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}},
    {2, "sender", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_SendMessageRequest_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    chatroom_SendMessageRequest.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::example::chatroom::Exception>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs_ref()->emplace("chatroom.Exception", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& chatroom_Exception = res.first->second;
  chatroom_Exception.name_ref() = "chatroom.Exception";
  chatroom_Exception.is_union_ref() = false;
  static const EncodedThriftField
  chatroom_Exception_fields[] = {
    {1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_Exception_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    field.structured_annotations_ref() = f.structured_annotations;
    chatroom_Exception.fields_ref()->push_back(std::move(field));
  }
  return res.first->second;
}

void ExceptionMetadata<::example::chatroom::Exception>::gen(ThriftMetadata& metadata) {
  auto res = metadata.exceptions_ref()->emplace("chatroom.Exception", ::apache::thrift::metadata::ThriftException{});
  if (!res.second) {
    return;
  }
  ::apache::thrift::metadata::ThriftException& chatroom_Exception = res.first->second;
  chatroom_Exception.name_ref() = "chatroom.Exception";
  static const EncodedThriftField
  chatroom_Exception_fields[] = {
    {1, "message", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{}},
  };
  for (const auto& f : chatroom_Exception_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id_ref() = f.id;
    field.name_ref() = f.name;
    field.is_optional_ref() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type_ref(), metadata);
    chatroom_Exception.fields_ref()->push_back(std::move(field));
  }
}
void ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen_initialize(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "initialize";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField chatroom_ChatRoomService_initialize_e_1;
  chatroom_ChatRoomService_initialize_e_1.id_ref() = 1;
  chatroom_ChatRoomService_initialize_e_1.name_ref() = "e";
  chatroom_ChatRoomService_initialize_e_1.is_optional_ref() = false;
  auto chatroom_ChatRoomService_initialize_e_1_type = std::make_unique<Struct< ::example::chatroom::Exception>>("chatroom.Exception");
  chatroom_ChatRoomService_initialize_e_1_type->writeAndGenType(*chatroom_ChatRoomService_initialize_e_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(chatroom_ChatRoomService_initialize_e_1));
  ExceptionMetadata< ::example::chatroom::Exception>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen_getMessages(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "getMessages";
  auto func_ret_type = std::make_unique<Struct< ::example::chatroom::GetMessagesResponse>>("chatroom.GetMessagesResponse");
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField chatroom_ChatRoomService_getMessages_req_1;
  chatroom_ChatRoomService_getMessages_req_1.id_ref() = 1;
  chatroom_ChatRoomService_getMessages_req_1.name_ref() = "req";
  chatroom_ChatRoomService_getMessages_req_1.is_optional_ref() = false;
  auto chatroom_ChatRoomService_getMessages_req_1_type = std::make_unique<Struct< ::example::chatroom::GetMessagesRequest>>("chatroom.GetMessagesRequest");
  chatroom_ChatRoomService_getMessages_req_1_type->writeAndGenType(*chatroom_ChatRoomService_getMessages_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(chatroom_ChatRoomService_getMessages_req_1));
  ::apache::thrift::metadata::ThriftField chatroom_ChatRoomService_getMessages_e_1;
  chatroom_ChatRoomService_getMessages_e_1.id_ref() = 1;
  chatroom_ChatRoomService_getMessages_e_1.name_ref() = "e";
  chatroom_ChatRoomService_getMessages_e_1.is_optional_ref() = false;
  auto chatroom_ChatRoomService_getMessages_e_1_type = std::make_unique<Struct< ::example::chatroom::Exception>>("chatroom.Exception");
  chatroom_ChatRoomService_getMessages_e_1_type->writeAndGenType(*chatroom_ChatRoomService_getMessages_e_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(chatroom_ChatRoomService_getMessages_e_1));
  ExceptionMetadata< ::example::chatroom::Exception>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}
void ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen_sendMessage(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "sendMessage";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_VOID_TYPE);
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField chatroom_ChatRoomService_sendMessage_req_1;
  chatroom_ChatRoomService_sendMessage_req_1.id_ref() = 1;
  chatroom_ChatRoomService_sendMessage_req_1.name_ref() = "req";
  chatroom_ChatRoomService_sendMessage_req_1.is_optional_ref() = false;
  auto chatroom_ChatRoomService_sendMessage_req_1_type = std::make_unique<Struct< ::example::chatroom::SendMessageRequest>>("chatroom.SendMessageRequest");
  chatroom_ChatRoomService_sendMessage_req_1_type->writeAndGenType(*chatroom_ChatRoomService_sendMessage_req_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(chatroom_ChatRoomService_sendMessage_req_1));
  ::apache::thrift::metadata::ThriftField chatroom_ChatRoomService_sendMessage_e_1;
  chatroom_ChatRoomService_sendMessage_e_1.id_ref() = 1;
  chatroom_ChatRoomService_sendMessage_e_1.name_ref() = "e";
  chatroom_ChatRoomService_sendMessage_e_1.is_optional_ref() = false;
  auto chatroom_ChatRoomService_sendMessage_e_1_type = std::make_unique<Struct< ::example::chatroom::Exception>>("chatroom.Exception");
  chatroom_ChatRoomService_sendMessage_e_1_type->writeAndGenType(*chatroom_ChatRoomService_sendMessage_e_1.type_ref(), metadata);
  func.exceptions_ref()->push_back(std::move(chatroom_ChatRoomService_sendMessage_e_1));
  ExceptionMetadata< ::example::chatroom::Exception>::gen(metadata);
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata_ref(), *response.services_ref());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module_ref() = *self->module_ref();
  context.service_info_ref() = response.metadata_ref()->services_ref()->at(*self->service_name_ref());
  response.context_ref() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::genRecurse(ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService chatroom_ChatRoomService;
  chatroom_ChatRoomService.name_ref() = "chatroom.ChatRoomService";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen_initialize,
    ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen_getMessages,
    ServiceMetadata<::example::chatroom::ChatRoomServiceSvIf>::gen_sendMessage,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, chatroom_ChatRoomService);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services_ref()->emplace("chatroom.ChatRoomService", std::move(chatroom_ChatRoomService));
  context.service_name_ref() = "chatroom.ChatRoomService";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "chatroom";
  context.module_ref() = std::move(module);
  return &context;
}
void ServiceMetadata<::example::chatroom::EchoSvIf>::gen_echo(ThriftMetadata& metadata, ThriftService& service) {
  ::apache::thrift::metadata::ThriftFunction func;
  (void)metadata;
  func.name_ref() = "echo";
  auto func_ret_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  func_ret_type->writeAndGenType(*func.return_type_ref(), metadata);
  ::apache::thrift::metadata::ThriftField chatroom_Echo_echo_message_1;
  chatroom_Echo_echo_message_1.id_ref() = 1;
  chatroom_Echo_echo_message_1.name_ref() = "message";
  chatroom_Echo_echo_message_1.is_optional_ref() = false;
  auto chatroom_Echo_echo_message_1_type = std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE);
  chatroom_Echo_echo_message_1_type->writeAndGenType(*chatroom_Echo_echo_message_1.type_ref(), metadata);
  func.arguments_ref()->push_back(std::move(chatroom_Echo_echo_message_1));
  func.is_oneway_ref() = false;
  service.functions_ref()->push_back(std::move(func));
}

void ServiceMetadata<::example::chatroom::EchoSvIf>::gen(::apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  const ::apache::thrift::metadata::ThriftServiceContextRef* self = genRecurse(*response.metadata_ref(), *response.services_ref());
  DCHECK(self != nullptr);
  // TODO(praihan): Remove ThriftServiceContext from response. But in the meantime, we need to fill the field with the result of looking up in ThriftMetadata.
  ::apache::thrift::metadata::ThriftServiceContext context;
  context.module_ref() = *self->module_ref();
  context.service_info_ref() = response.metadata_ref()->services_ref()->at(*self->service_name_ref());
  response.context_ref() = std::move(context);
}

const ThriftServiceContextRef* ServiceMetadata<::example::chatroom::EchoSvIf>::genRecurse(ThriftMetadata& metadata, std::vector<ThriftServiceContextRef>& services) {
  (void) metadata;
  ::apache::thrift::metadata::ThriftService chatroom_Echo;
  chatroom_Echo.name_ref() = "chatroom.Echo";
  static const ThriftFunctionGenerator functions[] = {
    ServiceMetadata<::example::chatroom::EchoSvIf>::gen_echo,
  };
  for (auto& function_gen : functions) {
    function_gen(metadata, chatroom_Echo);
  }
  // We need to keep the index around because a reference or iterator could be invalidated.
  auto selfIndex = services.size();
  services.emplace_back();
  ThriftServiceContextRef& context = services[selfIndex];
  metadata.services_ref()->emplace("chatroom.Echo", std::move(chatroom_Echo));
  context.service_name_ref() = "chatroom.Echo";
  ::apache::thrift::metadata::ThriftModuleContext module;
  module.name_ref() = "chatroom";
  context.module_ref() = std::move(module);
  return &context;
}
} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
